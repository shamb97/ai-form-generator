"""
Phase Manager - The Memory Keeper + Phase Transition Controller

This module tracks form completions separately for each phase AND manages phase transitions.
Think of it like: "Did I eat breakfast TODAY (this phase), or was that YESTERDAY (different phase)?"

Key Rule: Same form in different phases = different completions
Example: Consent form in Screening â‰  Consent form in Follow-Up

NEW: Phase Transition Management
- Validates transitions before they happen
- Creates audit trail
- Enforces completion requirements
"""

from datetime import date, datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

# Database imports (for phase transition features)
try:
    from .database import (
        get_allowed_transitions as db_get_allowed_transitions,
        get_transition_rule as db_get_transition_rule,
        create_phase_transition as db_create_phase_transition,
        get_phase_transition_history as db_get_phase_transition_history,
        get_current_phase as db_get_current_phase
    )
    DATABASE_AVAILABLE = True
    print("âœ… DATABASE_AVAILABLE = True (imports succeeded)")
except ImportError as e:
    # Running standalone for testing
    DATABASE_AVAILABLE = False


@dataclass
class Completion:
    """
    Records when a form was completed.
    
    Like a 5-year-old would understand:
    "I finished my math homework on Monday in Mrs. Smith's class"
    
    Attributes:
        form_id: Which form? (e.g., "daily_diary")
        phase: Which phase? (e.g., "screening", "intervention")
        day_type: What kind of day? (e.g., "A_ONLY", "ABC", "EVENT_EOT")
        completed_date: When? (e.g., 2024-11-06)
        participant_id: Who completed it? (for future multi-user support)
    """
    form_id: str
    phase: str
    day_type: str
    completed_date: date
    participant_id: str = "default_participant"
    
    def __repr__(self):
        return f"Completion(form={self.form_id}, phase={self.phase}, day_type={self.day_type}, date={self.completed_date})"


class PhaseManager:
    """
    The Memory Keeper + Phase Transition Controller
    
    Tracks what's been completed in each phase AND manages phase transitions.
    
    Like a teacher's gradebook that keeps track of:
    - Which assignments each student completed
    - In which class (phase)
    - On which day
    - When students move to the next grade (phase transition)
    
    Why we need this:
    - Prevents confusion: "Did I do this TODAY or YESTERDAY?"
    - Keeps phases separate: "Math homework â‰  Art homework"
    - Makes navigation smart: "What should I do NEXT?"
    - Controls phase transitions: "Can I move to the next phase?"
    """
    
    def __init__(self, db_session=None):
        """
        Initialize the memory keeper with an empty list of completions.
        
        Args:
            db_session: Optional database session for phase transition validation
        
        Like starting a new gradebook at the beginning of the school year.
        """
        self.completions: List[Completion] = []
        self.db = db_session
    
    def record_completion(
        self,
        form_id: str,
        phase: str,
        day_type: str,
        completed_date: Optional[date] = None,
        participant_id: str = "default_participant"
    ) -> Completion:
        """
        Record that a form was completed.
        
        Like a 5-year-old would understand:
        "I finished my spelling test in English class today!"
        
        Args:
            form_id: Which form? (e.g., "consent_form")
            phase: Which phase? (e.g., "screening")
            day_type: What kind of day? (e.g., "A_ONLY")
            completed_date: When? (defaults to today)
            participant_id: Who? (for future multi-user support)
        
        Returns:
            The completion record that was created
        
        Example:
            >>> pm = PhaseManager()
            >>> pm.record_completion("daily_diary", "intervention", "A_ONLY")
            Completion(form=daily_diary, phase=intervention, day_type=A_ONLY, date=2024-11-06)
        """
        if completed_date is None:
            completed_date = date.today()
        
        completion = Completion(
            form_id=form_id,
            phase=phase,
            day_type=day_type,
            completed_date=completed_date,
            participant_id=participant_id
        )
        
        self.completions.append(completion)
        return completion
    
    def is_form_done(
        self,
        form_id: str,
        phase: str,
        day_type: str,
        check_date: Optional[date] = None,
        participant_id: str = "default_participant"
    ) -> bool:
        """
        Check if a specific form was completed in a specific phase on a specific day.
        
        Like a 5-year-old would understand:
        "Did I already brush my teeth THIS MORNING (not yesterday morning)?"
        
        Args:
            form_id: Which form?
            phase: Which phase?
            day_type: What kind of day?
            check_date: Which day? (defaults to today)
            participant_id: Who?
        
        Returns:
            True if the form was completed, False otherwise
        
        Example:
            >>> pm = PhaseManager()
            >>> pm.record_completion("consent", "screening", "EVENT_BASELINE")
            >>> pm.is_form_done("consent", "screening", "EVENT_BASELINE")
            True
            >>> pm.is_form_done("consent", "intervention", "EVENT_BASELINE")
            False  # Different phase!
        """
        if check_date is None:
            check_date = date.today()
        
        # Look through all completions to find a match
        for completion in self.completions:
            if (completion.form_id == form_id and
                completion.phase == phase and
                completion.day_type == day_type and
                completion.completed_date == check_date and
                completion.participant_id == participant_id):
                return True
        
        return False
    
    def get_completions_for_phase(
        self,
        phase: str,
        participant_id: str = "default_participant"
    ) -> List[Completion]:
        """
        Get all completions for a specific phase.
        
        Like a 5-year-old would understand:
        "Show me all the homework I did in Math class"
        
        Args:
            phase: Which phase?
            participant_id: Who?
        
        Returns:
            List of all completions in that phase
        
        Example:
            >>> pm = PhaseManager()
            >>> pm.record_completion("form_a", "screening", "A_ONLY")
            >>> pm.record_completion("form_b", "screening", "AB")
            >>> pm.record_completion("form_c", "intervention", "A_ONLY")
            >>> len(pm.get_completions_for_phase("screening"))
            2  # Only screening completions
        """
        return [
            c for c in self.completions
            if c.phase == phase and c.participant_id == participant_id
        ]
    
    def get_completions_for_date(
        self,
        check_date: Optional[date] = None,
        participant_id: str = "default_participant"
    ) -> List[Completion]:
        """
        Get all completions for a specific date.
        
        Like a 5-year-old would understand:
        "What did I do today?"
        
        Args:
            check_date: Which day? (defaults to today)
            participant_id: Who?
        
        Returns:
            List of all completions on that date
        """
        if check_date is None:
            check_date = date.today()
        
        return [
            c for c in self.completions
            if c.completed_date == check_date and c.participant_id == participant_id
        ]
    
    def clear_completions(self, participant_id: str = "default_participant"):
        """
        Clear all completions for a participant.
        
        Like a 5-year-old would understand:
        "Erase everything from my notebook and start fresh"
        
        Useful for:
        - Testing
        - Starting a new study
        - Resetting data
        """
        self.completions = [
            c for c in self.completions
            if c.participant_id != participant_id
        ]
    
    def get_summary(self, participant_id: str = "default_participant") -> Dict:
        """
        Get a summary of all completions.
        
        Like a 5-year-old would understand:
        "How many homework assignments did I do in each class?"
        
        Returns:
            Dictionary with statistics about completions
        """
        participant_completions = [
            c for c in self.completions
            if c.participant_id == participant_id
        ]
        
        # Group by phase
        by_phase = {}
        for completion in participant_completions:
            if completion.phase not in by_phase:
                by_phase[completion.phase] = []
            by_phase[completion.phase].append(completion)
        
        return {
            "total_completions": len(participant_completions),
            "by_phase": {
                phase: len(comps) for phase, comps in by_phase.items()
            },
            "latest_completion": max(
                [c.completed_date for c in participant_completions],
                default=None
            )
        }
    
    # ==================== PHASE TRANSITION METHODS ====================
    
    def get_allowed_transitions(self, study_id: int, from_phase: str) -> List[str]:
        """
        Get all allowed phase transitions from the current phase.
        
        Like a 5-year-old would understand:
        "If I'm in 1st grade, which grades can I move to next?"
        
        Args:
            study_id: Which study?
            from_phase: Current phase (e.g., "screening")
        
        Returns:
            List of allowed next phases (e.g., ["baseline", "early_termination"])
        
        Example:
            >>> pm = PhaseManager(db)
            >>> pm.get_allowed_transitions(1, "screening")
            ["baseline", "early_termination"]
        """
        # DEBUG OUTPUT
        print(f"   study_id={study_id}, from_phase={from_phase}")
        print(f"   self.db={self.db}")
        print(f"   DATABASE_AVAILABLE={DATABASE_AVAILABLE}")
        
        if not self.db:
            # If no database, return default clinical trial flow
            print(f"   â†’ No database session, returning default flow")
            default_flow = {
                "screening": ["baseline", "early_termination"],
                "baseline": ["intervention", "early_termination"],
                "intervention": ["followup", "early_termination"],
                "followup": ["end_of_treatment"],
                "early_termination": [],
                "end_of_treatment": []
            }
            result = default_flow.get(from_phase.lower(), [])
            print(f"   â†’ Result: {result}")
            return result
        
        # Query database for allowed transitions
        if DATABASE_AVAILABLE:
            print(f"   â†’ DATABASE_AVAILABLE=True, calling db_get_allowed_transitions")
            result = db_get_allowed_transitions(self.db, study_id, from_phase)
            print(f"   â†’ Database result: {result}")
            return result
        else:
            print(f"   â†’ DATABASE_AVAILABLE=False, returning empty list")
            return []
    
    def validate_transition(
        self, 
        study_id: int,
        subject_id: str, 
        from_phase: str, 
        to_phase: str
    ) -> Tuple[bool, str]:
        """
        Validate if a phase transition is allowed.
        
        Like a 5-year-old would understand:
        "Can I move to 2nd grade? Did I finish all my 1st grade work?"
        
        Checks:
        1. Is this transition defined in the rules?
        2. Are all required forms complete?
        3. Any other blocking conditions?
        
        Args:
            study_id: Which study?
            subject_id: Which subject?
            from_phase: Current phase
            to_phase: Desired next phase
        
        Returns:
            Tuple of (is_valid: bool, reason: str)
            - (True, "Transition allowed")
            - (False, "Must complete 3 forms before transitioning")
        
        Example:
            >>> is_valid, reason = pm.validate_transition(1, "002", "baseline", "intervention")
            >>> if is_valid:
            >>>     print("âœ… Can transition!")
            >>> else:
            >>>     print(f"âŒ Cannot transition: {reason}")
        """
        # Check 1: Is this transition allowed?
        allowed_transitions = self.get_allowed_transitions(study_id, from_phase)
        
        if to_phase not in allowed_transitions:
            return False, f"Cannot transition from {from_phase} to {to_phase}. Allowed: {', '.join(allowed_transitions)}"
        
        # Check 2: Get transition rule requirements
        if self.db:
            if DATABASE_AVAILABLE:
                rule = db_get_transition_rule(self.db, study_id, from_phase, to_phase)
            else:
                rule = None
            
            if rule and rule.requires_completion:
                # Check if all forms in current phase are complete
                incomplete_count = self._count_incomplete_forms(subject_id, from_phase)
                
                if incomplete_count > 0:
                    return False, f"Must complete {incomplete_count} form(s) in {from_phase} phase before transitioning"
        
        # All checks passed!
        return True, "Transition allowed"
    
    def _count_incomplete_forms(self, subject_id: str, phase: str) -> int:
        """
        Count how many forms are incomplete in a phase.
        
        This is a helper method - in production, you'd query the database
        for all forms due in this phase and check completion status.
        
        For now, returns 0 (assuming all complete) unless you have
        completion tracking set up.
        """
        # TODO: Query database for incomplete forms
        # For now, return 0 to allow transitions
        return 0
    
    def execute_transition(
        self,
        study_id: int,
        subject_id: str,
        from_phase: str,
        to_phase: str,
        transition_day: int,
        triggered_by: str,
        triggered_by_user_id: Optional[str] = None
    ) -> Dict:
        """
        Execute a phase transition with validation and audit trail.
        
        Like a 5-year-old would understand:
        "Move me to the next grade and write it down in my report card"
        
        Args:
            study_id: Which study?
            subject_id: Which subject?
            from_phase: Current phase
            to_phase: New phase
            transition_day: Study day when transition happens
            triggered_by: How? ("automatic", "investigator", "event")
            triggered_by_user_id: Who triggered it? (investigator ID)
        
        Returns:
            Dictionary with:
            - success: bool
            - transition_id: int (database ID)
            - audit_entry: dict (audit trail info)
            - error: str (if success=False)
        
        Example:
            >>> result = pm.execute_transition(
            >>>     study_id=1,
            >>>     subject_id="002",
            >>>     from_phase="baseline",
            >>>     to_phase="intervention",
            >>>     transition_day=14,
            >>>     triggered_by="investigator",
            >>>     triggered_by_user_id="INV001"
            >>> )
            >>> print(result["success"])  # True
            >>> print(result["transition_id"])  # 42
        """
        # Step 1: Validate transition
        is_valid, reason = self.validate_transition(study_id, subject_id, from_phase, to_phase)
        
        if not is_valid:
            return {
                "success": False,
                "error": reason
            }
        
        # Step 2: Record transition in database
        if not self.db:
            return {
                "success": False,
                "error": "Database session required for phase transitions"
            }
        
        try:
            if not DATABASE_AVAILABLE:
                raise Exception("Database not available")
                
            transition = db_create_phase_transition(
                db=self.db,
                study_id=study_id,
                subject_id=subject_id,
                from_phase=from_phase,
                to_phase=to_phase,
                transition_day=transition_day,
                triggered_by=triggered_by,
                triggered_by_user_id=triggered_by_user_id
            )
            
            # Create audit entry
            audit_entry = {
                "transition_id": transition.id,
                "subject_id": subject_id,
                "from_phase": from_phase,
                "to_phase": to_phase,
                "transition_day": transition_day,
                "triggered_by": triggered_by,
                "triggered_by_user_id": triggered_by_user_id,
                "timestamp": transition.timestamp.isoformat()
            }
            
            return {
                "success": True,
                "transition_id": transition.id,
                "audit_entry": audit_entry,
                "new_phase": to_phase
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to record transition: {str(e)}"
            }
    
    def get_phase_history(self, subject_id: str) -> List[Dict]:
        """
        Get the complete phase transition history for a subject.
        
        Like a 5-year-old would understand:
        "Show me all the grades I've been in"
        
        Args:
            subject_id: Which subject?
        
        Returns:
            List of transitions, newest first
        
        Example:
            >>> history = pm.get_phase_history("002")
            >>> for transition in history:
            >>>     print(f"{transition['from_phase']} -> {transition['to_phase']}")
        """
        if not self.db:
            return []
        
        try:
            if not DATABASE_AVAILABLE:
                return []

            transitions = db_get_phase_transition_history(self.db, subject_id)
            
            return [{
                "id": t.id,
                "from_phase": t.from_phase,
                "to_phase": t.to_phase,
                "transition_day": t.transition_day,
                "triggered_by": t.triggered_by,
                "triggered_by_user_id": t.triggered_by_user_id,
                "timestamp": t.timestamp.isoformat()
            } for t in transitions]
            
        except Exception as e:
            print(f"Error fetching phase history: {e}")
            return []
    
    def get_current_phase(self, subject_id: str) -> Optional[str]:
        """
        Get the current phase for a subject.
        
        Like a 5-year-old would understand:
        "What grade am I in right now?"
        
        Args:
            subject_id: Which subject?
        
        Returns:
            Current phase name, or None if no transitions recorded
        
        Example:
            >>> current = pm.get_current_phase("002")
            >>> print(f"Subject is in: {current}")  # "intervention"
        """
        if not self.db:
            return None
        
        try:
            if not DATABASE_AVAILABLE:
                return None
                
            return db_get_current_phase(self.db, subject_id)
        except Exception as e:
            print(f"Error fetching current phase: {e}")
            return None


# Example usage (for demonstration)
if __name__ == "__main__":
    print("ğŸ§ª Testing Enhanced Phase Manager...\n")
    
    # Create a new phase manager (without database for basic tests)
    pm = PhaseManager()
    
    # ==================== PART 1: COMPLETION TRACKING ====================
    print("=" * 60)
    print("PART 1: COMPLETION TRACKING (Original Functionality)")
    print("=" * 60 + "\n")
    
    # Scenario: A participant completes forms across multiple phases
    print("ğŸ“ Recording completions...")
    pm.record_completion("consent_form", "screening", "EVENT_BASELINE", date(2024, 11, 1))
    pm.record_completion("daily_diary", "intervention", "A_ONLY", date(2024, 11, 5))
    pm.record_completion("daily_diary", "intervention", "A_ONLY", date(2024, 11, 6))
    pm.record_completion("weekly_qol", "intervention", "AB", date(2024, 11, 6))
    
    print("âœ… Recorded 4 completions\n")
    
    # Test 1: Check if form is done in specific phase
    print("ğŸ” Test 1: Is 'daily_diary' done in intervention on 2024-11-06?")
    result = pm.is_form_done("daily_diary", "intervention", "A_ONLY", date(2024, 11, 6))
    print(f"   Result: {result} âœ…\n")
    
    # Test 2: Check if same form is done in different phase
    print("ğŸ” Test 2: Is 'daily_diary' done in screening on 2024-11-06?")
    result = pm.is_form_done("daily_diary", "screening", "A_ONLY", date(2024, 11, 6))
    print(f"   Result: {result} âŒ (Different phase!)\n")
    
    # Test 3: Get summary
    print("ğŸ“Š Summary:")
    summary = pm.get_summary()
    print(f"   Total completions: {summary['total_completions']}")
    print(f"   By phase: {summary['by_phase']}")
    print(f"   Latest completion: {summary['latest_completion']}\n")
    
    # ==================== PART 2: PHASE TRANSITIONS ====================
    print("=" * 60)
    print("PART 2: PHASE TRANSITIONS (New Functionality)")
    print("=" * 60 + "\n")
    
    print("ğŸ”„ Testing phase transition validation...\n")
    
    # Test 1: Get allowed transitions
    print("ğŸ” Test 1: What phases can we go to from 'screening'?")
    allowed = pm.get_allowed_transitions(1, "screening")
    print(f"   Allowed: {allowed}\n")
    
    # Test 2: Validate a valid transition
    print("ğŸ” Test 2: Can we go from 'screening' to 'baseline'?")
    is_valid, reason = pm.validate_transition(1, "002", "screening", "baseline")
    print(f"   Valid: {is_valid}")
    print(f"   Reason: {reason}\n")
    
    # Test 3: Validate an invalid transition
    print("ğŸ” Test 3: Can we go from 'screening' to 'followup'?")
    is_valid, reason = pm.validate_transition(1, "002", "screening", "followup")
    print(f"   Valid: {is_valid}")
    print(f"   Reason: {reason}\n")
    
    print("âœ… Enhanced Phase Manager working correctly!")
    print("\nğŸ’¡ Note: To test database integration, initialize with:")
    print("   pm = PhaseManager(db_session)")